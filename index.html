<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3Dãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ </title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 100%);
      font-family: 'Arial', sans-serif;
      color: white;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #settings {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 100;
      min-width: 250px;
    }
    #settings.open {
      transform: translateX(0);
    }
    #settingsToggle {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 170, 255, 0.9);
      border: none;
      padding: 12px 16px;
      border-radius: 8px;
      cursor: pointer;
      color: white;
      font-size: 18px;
      transition: all 0.2s ease;
      z-index: 101;
    }
    #settingsToggle:hover {
      background: rgba(0, 170, 255, 1);
      transform: scale(1.05);
    }
    #mainControls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 25px;
      border-radius: 25px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 20px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 14px;
      line-height: 1.6;
    }
    .btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      padding: 10px 18px;
      border-radius: 8px;
      cursor: pointer;
      color: white;
      font-size: 14px;
      transition: all 0.2s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }
    .btn:active {
      transform: translateY(0);
    }
    .btn.active {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }
    .control-group {
      margin-bottom: 20px;
    }
    .control-group label {
      display: block;
      margin-bottom: 8px;
      font-size: 13px;
      color: #ccc;
    }
    input[type="range"] {
      width: 100%;
      -webkit-appearance: none;
      height: 6px;
      border-radius: 3px;
      background: #333;
      outline: none;
      margin: 8px 0;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }
    input[type="number"] {
      width: 60px;
      padding: 6px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #333;
      color: white;
      font-size: 12px;
    }
    .value-display {
      color: #00aaff;
      font-weight: bold;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .playing {
      animation: pulse 1s infinite;
    }
  </style>
</head>
<body>
  <div id="info">
    <div>ã‚¿ãƒ¼ãƒ³: <span id="turnCount">0</span></div>
    <div>ç”Ÿå­˜ã‚»ãƒ«: <span id="aliveCount">0</span></div>
    <div>å¯†åº¦: <span id="density">0</span>%</div>
  </div>

  <button id="settingsToggle">âš™ï¸</button>

  <div id="settings">
    <h3 style="margin-top: 0; color: #00aaff;">ã‚²ãƒ¼ãƒ è¨­å®š</h3>
    <div class="control-group">
      <label>ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º: <span class="value-display" id="gridSizeValue">10</span></label>
      <input type="range" id="gridSize" min="6" max="16" value="10">
    </div>
    <div class="control-group">
      <label>åˆæœŸå¯†åº¦: <span class="value-display" id="densityValue">15</span>%</label>
      <input type="range" id="initialDensity" min="5" max="40" value="15">
    </div>
    <div class="control-group">
      <label>ç”Ÿå­˜ãƒ«ãƒ¼ãƒ« (éš£æ¥æ•°): <input type="number" id="surviveMin" min="1" max="10" value="4"> - <input type="number" id="surviveMax" min="1" max="15" value="5"></label>
    </div>
    <div class="control-group">
      <label>èª•ç”Ÿãƒ«ãƒ¼ãƒ« (éš£æ¥æ•°): <input type="number" id="birthRule" min="1" max="15" value="5"></label>
    </div>
    <div class="control-group">
      <label>è‡ªå‹•å†ç”Ÿé€Ÿåº¦: <span class="value-display" id="speedValue">800</span>ms</label>
      <input type="range" id="speed" min="100" max="2000" value="800">
    </div>
    <div class="control-group">
      <button class="btn" id="applySettings">è¨­å®šã‚’é©ç”¨</button>
    </div>
    <div class="control-group">
      <label>ãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆ:</label>
      <button class="btn" id="randomPattern" style="width: 100%; margin-bottom: 8px;">ãƒ©ãƒ³ãƒ€ãƒ </button>
      <button class="btn" id="clusterPattern" style="width: 100%; margin-bottom: 8px;">ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼</button>
      <button class="btn" id="spherePattern" style="width: 100%;">çƒä½“</button>
    </div>
  </div>

  <div id="mainControls">
    <button class="btn" id="stepBtn">â–¶ï¸ æ¬¡ä¸–ä»£</button>
    <button class="btn" id="playBtn">â¯ï¸ è‡ªå‹•å†ç”Ÿ</button>
    <button class="btn" id="resetBtn">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
    <button class="btn" id="rotateBtn">ğŸ”„ å›è»¢</button>
  </div>

  <script>
    // ã‚²ãƒ¼ãƒ è¨­å®š
    let config = {
      gridSize: 10,
      initialDensity: 0.15,
      surviveMin: 4,
      surviveMax: 5,
      birthRule: 5,
      speed: 800
    };

    // Three.jsã®åŸºæœ¬è¨­å®š
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 50, 200);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // ã‚«ãƒ¡ãƒ©è¨­å®š
    camera.position.set(30, 30, 30);
    camera.lookAt(0, 0, 0);

    // ãƒã‚¦ã‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆç°¡æ˜“ç‰ˆï¼‰
    let mouseX = 0, mouseY = 0;
    let targetRotationX = 0, targetRotationY = 0;
    let isMouseDown = false;
    let rotationDampening = 0.95;

    document.addEventListener('mousedown', () => isMouseDown = true);
    document.addEventListener('mouseup', () => isMouseDown = false);
    document.addEventListener('mousemove', (event) => {
      if (isMouseDown) {
        mouseX = (event.clientX / window.innerWidth) * 2 - 1;
        mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        targetRotationY = mouseX * Math.PI;
        targetRotationX = mouseY * Math.PI * 0.5;
      }
    });

    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let cells = [];
    let cellGroup = new THREE.Group();
    scene.add(cellGroup);
    let turn = 0;
    let isPlaying = false;
    let isRotating = false;
    let lastTime = 0;

    // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0x00aaff, 0.8, 100);
    pointLight.position.set(-30, 30, -30);
    scene.add(pointLight);

    // ã‚»ãƒ«ã®ãƒãƒ†ãƒªã‚¢ãƒ«ã¨ã‚¸ã‚ªãƒ¡ãƒˆãƒª
    const cellGeometry = new THREE.BoxGeometry(1, 1, 1);
    const cellMaterial = new THREE.MeshLambertMaterial({ 
      color: 0x00ff88,
      transparent: true,
      opacity: 0.9
    });

    // åˆæœŸåŒ–
    function initializeGrid() {
      scene.remove(cellGroup);
      cellGroup = new THREE.Group();
      scene.add(cellGroup);
      
      cells = [];
      turn = 0;
      updateDisplay();

      // ã‚°ãƒªãƒƒãƒ‰åˆæœŸåŒ–
      for (let x = 0; x < config.gridSize; x++) {
        cells[x] = [];
        for (let y = 0; y < config.gridSize; y++) {
          cells[x][y] = new Array(config.gridSize).fill(null).map(() => ({ alive: false }));
        }
      }

      generateRandomPattern();
      renderCells();
    }

    // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆ
    function generateRandomPattern() {
      clearCells();
      const totalCells = config.gridSize ** 3;
      const targetCount = Math.floor(totalCells * config.initialDensity);
      let count = 0;

      while (count < targetCount) {
        const x = Math.floor(Math.random() * config.gridSize);
        const y = Math.floor(Math.random() * config.gridSize);
        const z = Math.floor(Math.random() * config.gridSize);
        
        if (!cells[x][y][z].alive) {
          cells[x][y][z].alive = true;
          count++;
        }
      }
      renderCells();
    }

    // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆ
    function generateClusterPattern() {
      clearCells();
      const clusterCount = Math.floor(config.gridSize / 3);
      
      for (let i = 0; i < clusterCount; i++) {
        const centerX = Math.floor(Math.random() * config.gridSize);
        const centerY = Math.floor(Math.random() * config.gridSize);
        const centerZ = Math.floor(Math.random() * config.gridSize);
        const radius = Math.random() * 3 + 1;
        
        for (let x = 0; x < config.gridSize; x++) {
          for (let y = 0; y < config.gridSize; y++) {
            for (let z = 0; z < config.gridSize; z++) {
              const distance = Math.sqrt(
                (x - centerX) ** 2 + (y - centerY) ** 2 + (z - centerZ) ** 2
              );
              if (distance <= radius && Math.random() < 0.7) {
                cells[x][y][z].alive = true;
              }
            }
          }
        }
      }
      renderCells();
    }

    // çƒä½“ãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆ
    function generateSpherePattern() {
      clearCells();
      const center = config.gridSize / 2;
      const radius = config.gridSize * 0.3;
      
      for (let x = 0; x < config.gridSize; x++) {
        for (let y = 0; y < config.gridSize; y++) {
          for (let z = 0; z < config.gridSize; z++) {
            const distance = Math.sqrt(
              (x - center) ** 2 + (y - center) ** 2 + (z - center) ** 2
            );
            if (distance <= radius && Math.random() < 0.5) {
              cells[x][y][z].alive = true;
            }
          }
        }
      }
      renderCells();
    }

    function clearCells() {
      for (let x = 0; x < config.gridSize; x++) {
        for (let y = 0; y < config.gridSize; y++) {
          for (let z = 0; z < config.gridSize; z++) {
            cells[x][y][z].alive = false;
          }
        }
      }
    }

    // ã‚»ãƒ«æç”»
    function renderCells() {
      cellGroup.clear();
      let aliveCount = 0;
      
      const offset = config.gridSize / 2 - 0.5;
      for (let x = 0; x < config.gridSize; x++) {
        for (let y = 0; y < config.gridSize; y++) {
          for (let z = 0; z < config.gridSize; z++) {
            if (cells[x][y][z].alive) {
              const cube = new THREE.Mesh(cellGeometry, cellMaterial.clone());
              cube.position.set(
                (x - offset) * 1.2,
                (y - offset) * 1.2,
                (z - offset) * 1.2
              );
              
              const hue = (x + y + z) / (config.gridSize * 3);
              cube.material.color.setHSL(hue * 0.3 + 0.3, 0.8, 0.6);
              
              cube.castShadow = true;
              cube.receiveShadow = true;
              cellGroup.add(cube);
              aliveCount++;
            }
          }
        }
      }
      updateDisplay(aliveCount);
    }

    // è¿‘å‚ã‚»ãƒ«ã‚«ã‚¦ãƒ³ãƒˆ
    function countNeighbors(x, y, z) {
      let count = 0;
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          for (let dz = -1; dz <= 1; dz++) {
            if (dx === 0 && dy === 0 && dz === 0) continue;
            const nx = x + dx, ny = y + dy, nz = z + dz;
            if (nx >= 0 && nx < config.gridSize && 
                ny >= 0 && ny < config.gridSize && 
                nz >= 0 && nz < config.gridSize && 
                cells[nx][ny][nz].alive) {
              count++;
            }
          }
        }
      }
      return count;
    }

    // ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ æ›´æ–°
    function updateLifeGame() {
      const nextState = [];
      for (let x = 0; x < config.gridSize; x++) {
        nextState[x] = [];
        for (let y = 0; y < config.gridSize; y++) {
          nextState[x][y] = new Array(config.gridSize).fill(null).map(() => ({ alive: false }));
          for (let z = 0; z < config.gridSize; z++) {
            const alive = cells[x][y][z].alive;
            const neighbors = countNeighbors(x, y, z);
            
            let nextAlive = false;
            if (alive) {
              nextAlive = neighbors >= config.surviveMin && neighbors <= config.surviveMax;
            } else {
              nextAlive = neighbors === config.birthRule;
            }
            
            nextState[x][y][z] = { alive: nextAlive };
          }
        }
      }
      
      cells = nextState;
      turn++;
      renderCells();
    }

    // è¡¨ç¤ºæ›´æ–°
    function updateDisplay(aliveCount = null) {
      document.getElementById('turnCount').textContent = turn;
      if (aliveCount !== null) {
        document.getElementById('aliveCount').textContent = aliveCount;
        const totalCells = config.gridSize ** 3;
        const density = Math.round((aliveCount / totalCells) * 100);
        document.getElementById('density').textContent = density;
      }
    }

    // UIè¨­å®šæ›´æ–°
    function updateSettingsDisplay() {
      document.getElementById('gridSizeValue').textContent = config.gridSize;
      document.getElementById('densityValue').textContent = Math.round(config.initialDensity * 100);
      document.getElementById('speedValue').textContent = config.speed;
      
      document.getElementById('gridSize').value = config.gridSize;
      document.getElementById('initialDensity').value = Math.round(config.initialDensity * 100);
      document.getElementById('speed').value = config.speed;
      document.getElementById('surviveMin').value = config.surviveMin;
      document.getElementById('surviveMax').value = config.surviveMax;
      document.getElementById('birthRule').value = config.birthRule;
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    document.getElementById('settingsToggle').onclick = () => {
      const settings = document.getElementById('settings');
      settings.classList.toggle('open');
      if (settings.classList.contains('open')) {
        updateSettingsDisplay();
      }
    };

    document.getElementById('gridSize').oninput = (e) => {
      document.getElementById('gridSizeValue').textContent = e.target.value;
    };

    document.getElementById('initialDensity').oninput = (e) => {
      document.getElementById('densityValue').textContent = e.target.value;
    };

    document.getElementById('speed').oninput = (e) => {
      document.getElementById('speedValue').textContent = e.target.value;
      config.speed = parseInt(e.target.value);
    };

    document.getElementById('applySettings').onclick = () => {
      config.gridSize = parseInt(document.getElementById('gridSize').value);
      config.initialDensity = parseInt(document.getElementById('initialDensity').value) / 100;
      config.speed = parseInt(document.getElementById('speed').value);
      config.surviveMin = parseInt(document.getElementById('surviveMin').value);
      config.surviveMax = parseInt(document.getElementById('surviveMax').value);
      config.birthRule = parseInt(document.getElementById('birthRule').value);
      
      initializeGrid();
      document.getElementById('settings').classList.remove('open');
    };

    document.getElementById('stepBtn').onclick = () => updateLifeGame();
    
    document.getElementById('playBtn').onclick = () => {
      isPlaying = !isPlaying;
      const btn = document.getElementById('playBtn');
      btn.classList.toggle('active', isPlaying);
      btn.classList.toggle('playing', isPlaying);
      btn.innerHTML = isPlaying ? 'â¸ï¸ åœæ­¢' : 'â¯ï¸ è‡ªå‹•å†ç”Ÿ';
    };

    document.getElementById('resetBtn').onclick = () => {
      isPlaying = false;
      const playBtn = document.getElementById('playBtn');
      playBtn.classList.remove('active', 'playing');
      playBtn.innerHTML = 'â¯ï¸ è‡ªå‹•å†ç”Ÿ';
      initializeGrid();
    };
    
    document.getElementById('rotateBtn').onclick = () => {
      isRotating = !isRotating;
      const btn = document.getElementById('rotateBtn');
      btn.classList.toggle('active', isRotating);
      btn.innerHTML = isRotating ? 'â¹ï¸ å›è»¢åœæ­¢' : 'ğŸ”„ å›è»¢';
    };

    document.getElementById('randomPattern').onclick = () => {
      generateRandomPattern();
      updateDisplay();
    };
    document.getElementById('clusterPattern').onclick = () => {
      generateClusterPattern();
      updateDisplay();
    };
    document.getElementById('spherePattern').onclick = () => {
      generateSpherePattern();
      updateDisplay();
    };

    // ãƒªã‚µã‚¤ã‚ºå‡¦ç†
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
    function animate(time) {
      requestAnimationFrame(animate);
      
      if (isRotating) {
        cellGroup.rotation.y += 0.005;
        cellGroup.rotation.x += 0.0025;
      } else {
        cellGroup.rotation.y += (targetRotationY - cellGroup.rotation.y) * 0.05;
        cellGroup.rotation.x += (targetRotationX - cellGroup.rotation.x) * 0.05;
      }
      
      if (isPlaying && time - lastTime > config.speed) {
        updateLifeGame();
        lastTime = time;
      }
      
      renderer.render(scene, camera);
    }

    // åˆæœŸåŒ–
    initializeGrid();
    updateSettingsDisplay();
    animate(0);
  </script>
</body>
</html>
